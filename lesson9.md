## Архитектура проекта
***

## Автозагрузка
#### В чем проблема:
- В том, что когда нужен некий класс, нужно писать require;
- И даже require_once не особенно спасает - все равно приходится вручную отслеживать загрузку классов из файлов:
~~~php
function __autoload($className) {
    require __DIR__ . '/classes/' . $className . '.php';
}
~~~
#### Что делать:
- Функцию __autoload() нужно только объявить. Вызывать ее не требуется. 
- Функция будет вызвана автоматически, когда код встретит ранее неизвестное имя класса. Это имя будет передано функции. Её задача - подключить файл, где этот класс определен;
- Саму функцию поместить в отдельный файл autoload.php, а где нужно ее вызвать, написать:
~~~php
require __DIR__ . '/autoload.php';
~~~
- Функция автозагрузки работает с классами, интерфейсами и трейтами.
___


### Цепочка автозагрузки.
#### Задача: проект состоит из нескольких частей, каждая из них - со своей автозагрузкой.
Задача решается так называемой "цепочкой автозагрузки".

~~~php
spl_autoload_register(callable $autoload)
~~~
Функция из состава SPL. Регистрирует заданную функцию в очереди в качестве реализации автозагрузки.
Она создает очередь из функций автозагрузки в порядке их определения в скрипте.
~~~php
spl_autoload_register(function ($class) {
    require __DIR__ . '/../' . str_replace('\\', '/', $class) . '.php';
});
~~~
___
### Пространства имен (NAMESPACE)
#### Пространство имен - своеобразная "папка" в которой может находиться класс. Это просто часть имени класса.
~~~php
namespace App\Models;

class News {
    ...
}
~~~
Полное имя класса будет:
> \App\Models\News

Если в автозагрузку передать \App\Models\News, то автозагрузка сломается. Для того чтобы оно заработало, необходимо
создать папки с такими же именами, как и пространство имен и переместить туда классы, т.е. каждому пространству имен
будет соответствовать вложенная папка в приложении. Тем самым выстроится иерархия.


Можно использовать конструкцию use, чтобы задать короткие синонимы для «длинных» имен:
~~~php
use \App\Models\News as Model;
$model = new Model();
~~~
Считается, что классы, у которых не указано пространство имен, находятся в "корневом". То есть можно писать \Config или просто Config.

#### Важно! В функцию автозагрузки будет передано ПОЛНОЕ имя класса, включая пространство имен от корневого.

В стандарте написано, что любой код на языке php обязан использовать пространство имен, т.е. в приложении не должно быть классов вне пространства имен.

Необходимо разделять классы по функционалу. Классы отвечающие за модели данных, т.е. за работу с данными, должны лежать в папке Models.
___


### Паттерн MVC.
#### Архитектура - это базовая организация системы, воплощенная в ее компонентах, их отношениях между собой и с окружением, а также принципы, определяющие проектирование и развитие системы.
- Компоненты кода ("на какие части разбить");
- Структура кода ("где что будет лежать");
- Отношения между компонентами.

#### Паттерны проектирования - "шаблоны" построения программы, следуя которым, можно получить удовлетворительный результат.

#### Модель MODEL
- Слой работающий с данными;
- Ее задача - дать нужные данные тем компонентам, которые их запрашивают;
- Модель и только модель, знает, где данные находятся, как они организованы;
- Модель и только модель умеет обновлять, вставлять и удалять данные (CRUD).

#### Представление VIEW
- Часть кода, которая формирует ответ клиенту;
- Представление использует HTML, CSS, JavaScript;
- Представление может содержать логику, нужную для вывода данных, она может быть написана на php - не бойтесь смешивать php b html.

#### Контроллер CONTROLLER
- Контроллер - точка входа в приложение (принимает запрос от клиента, это значит использование GET, POST, COOKIES вне контроллера, это нарушение MVC);
- Получает нужные данные от моделей или дает моделям команды на модификацию данных;
- Обрабатывает эти данные в соответствии с бизнес-логикой;
- Передает данные представлению и инициирует ответ на запрос клиента.