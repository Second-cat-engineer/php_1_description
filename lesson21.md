## Модели данных и ООП
***

## Модели в MVC
### Строим систему моделей:
#### 1. Собрать в одном классе работу с БД. Класс Db должен удовлетворять следующим условиям:
- Создает и инкапсулирует соединение с базой данных;
- Умеет выполнять ЛЮБЫЕ запросы к БД;
- Возвращает результаты запросов и данные;
- Обрабатывает ошибки.

Можно определить, доступно ли свойство или метод "извне" или нет. Это называется "видимость". Например:
~~~php
class Item {
    public $color;
    protected $owner;
}

$item = new Item;
$item->color = 'red';
$item->owner = $admin;      // ОШИБКА!
~~~
Ключевое слово protected вместо public приводит к тому, что обращение к свойству или методу напрямую вызывает ошибку.
Однако "внутри", то есть в методах объекта, через $this, такое свойство/метод по-прежнему доступно.
Совокупность всех публичных свойств и методов называется "интерфейс".



#### 2. Модели данных. ORM. 
Объекты принято использовать в качестве МОДЕЛЕЙ данных:
1. ORM - Object Relational Mapping, или, иначе говоря, принцип отображения объектов реального мира (и их связей) на объекты языка программирования;
2. ООП прекрасно подходит для реализации этого шаблона проектирования: 
- Класс описывает какие объекты данных могут быть,
- Сами данные представлены объектами заданных классов,
- И сразу можно определить "поведение" в виде методов этих объектов.

#### Задача: "заставить" класс Db возвращать не просто данные в массивах, а объекты нужного класса.

- Вообще говоря, было бы круто "заставить" класс User самого искать нужные данные в БД. Например так:
~~~php
$user = new User();
$users = $user->findAll();
~~~
- Однако получается какой-то абсурд... Мы создаем нового пользователя и просим его найти всех пользователей? Что за бред?
- Решение проблемы - статические методы. Это методы, которые принадлежат КЛАССУ в целом, а не конкретным объектам. Это метод, который нельзя вызвать у объекта.
У него нет $this, он с объектом никак не связан. Это метод который описан в классе и работает с классом в целом.
В статическом методе не должно быть $this:
~~~php
class User {
    public $email;
    public $name;
    
    public static function findAll() {
        ...
    }
}

$users = User::findAll();
~~~

#### Статические методы и свойства:
- Кроме методов статическими могут быть и свойства:
~~~php
class User {
    public static $table = 'users';
    
    public static function findAll() {
        ...
    }
}

echo User::$table;
~~~
- Однако, часто бывает, что в общем-то не нужно изменять некое значение, связанное с классом (имя таблицы в модели).
В этом случае применяют константы:
~~~php
class User {
    public const TABLE = 'users';
    ...
}

echo User::TABLE;
~~~
- Иногда требуется обратиться к статическому свойству, методу или классу из самого класса:
~~~php
class User {
    protected static $table = 'users';
    
    public static function getTable () {
        return User::$table;
    }
} 
~~~
- Однако такой код неоптимален. Представим, что нам нужно переименовать класс User - сколько нужно найти мест! Поэтому применяют слово self - оно значит "этот класс":
~~~php
class User {
    public static function getTable () {
        return self::$table;
    }
} 
~~~


Ключевое слово self связывается всегда с тем классом, где оно написано. 
При вызове метода, который определен в родителе, в классе-наследнике, self будет смотреть в класс-родитель, даже если свойство переопределено:
~~~php
class First {
    public static $test = 1;
    
    public static function test() {
        echo self::$test;               // Это раннее статическое связывание
    }
}

class Second extends First {
    public static $test = 2;
}

Second::test(); // 1
~~~
Почему статическое? Потому что оно относится только к статическим методам, свойствам, константам.
Почему ранее? Потому что оно возникает на раннем этапе когда код еще не выполняется, на этапе компиляции.

Слово self нужно заменить на static.
static обозначает тот класс, который реально будет вызывать этот код. Это называется позднее статическое связывание.


#### 3. Абстрактные классы. LSB.
#### Абстрактный класс - это класс, который не позволяет создание объектов этого класса.
Нужно решить еще одну проблему: надо понять, что делать, когда моделей станет много? Ведь приложение, это несколько десятков таблиц в БД.
И получается в каждом классе некоторый код повторяется. Поэтому нужно выделить то, что повторяется, т.е. нужно выделить общий родительский класс Model.

Однако, я не предполагаю создание объектов класса Model. Поэтому в php есть специальный механизм под названием абстрактные классы.

Написав 
> abstract class Model { ... }

приводит к тому, что мы не можем создать объект класса Model.

Для чего нужен такой класс?
1. Для того чтобы от него наследоваться;
2. Для того чтобы использовать static.

В абстрактном классе могут быть как обычные свойства и методы, так и абстрактные методы:
1. Они содержат только заголовок;
2. Отсутствует собственно код метода;
3. Дочерний класс обязан такой метод реализовать в точном соответствии с заголовком из абстрактного класса, иначе будет ошибка.

Любой класс, в котором есть хотя бы один абстрактный метод, обязан быть абстрактным.
