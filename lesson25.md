## Исключения
***

## Понятие исключения
Обработка исключительных ситуаций - механизм языков программирования, предназначенный для описания реакции программы на 
ошибки времени выполнения и другие возможные проблемы (исключения), которые могут возникнуть при выполнении программы и
приводят к невозможности (бессмысленности) дальнейшей отработки программой ее базового алгоритма.


#### Исключение - это ситуация, при которой дальнейшее нормальное выполнение невозможно или бессмысленно.
Исключение, в отличие от, например, фатальной ошибки, ожидаемо нами. Мы готовы к ее появлению и к обработке
исключительной ситуации.

Исключение - это всегда ситуация, возникающая во время выполнения программы. Ошибки парсера или компилятора никак не 
могут называться исключениями, поскольку к этому моменту программы еще не запущена.
___

## Примеры исключений
- Деление на ноль - на дальнейшее вычисления, ни попытки использовать результат операции не приведут ни к чему хорошему;
- Разрыв соединения с БД - исключительная ситуация, которая может возникнуть в любой момент и сделать бессмысленной или даже вредной дальнейшую нормальную работу программы;
- Отсутствие нужного файла, из которого предполагалось чтение;
- Неверный пароль в форме входа;
- Бессмыслица в поле для поиска по сайту;
- Отсутствие пользователя, которому предназначается сообщение.
___


## Исключения в PHP
Исключения в php - это объект. В php существует ряд классов для представления исключений (описать, какая исключительная ситуация возникла).

Существуют два базовых класса:
- Error;
- Exception.

У этих классов есть общий интерфейс Throwable, его нельзя реализовать напрямую.
У этих классов разные цели.

Класс Error использует сам php. Не напрямую, а наследуя от него ряд других классов:
- TypeError - ошибка контроля типов;
- ParseError - ошибка парсинга php кода;
- DivisionByZeroError - деление на ноль;
- AssertionError - проверка в коде не прошла;
- ArithmeticError - какая то вычислительная операция пошла не так.

Класс Exception является базовым для всех пользовательских исключений. Вы можете наследовать свои классы от него.
___


## Объект-исключение
Объект-исключения можно создать с помощью обычного конструктора соответствующего класса исключения:
~~~php
$ex1 = new Exception;

$ex2 = new Exception('DB error');

$ex3 = new Exception('DB error', 404);
~~~

> "Можно создавать объект-исключение".

Правильно:
> "Объект, инкапсулирующий в себе информацию о возникшей исключительной ситуации".

Объект-исключение это вполне себе обычный объект. Его можно присвоить переменной, передать как аргумент, вызвать его методы:
~~~php
echo $ex2->getMessage();

$code = $ex3->getCode();
~~~

#### И эти объекты можно бросить!
~~~php
throw new Exception('Aaa!');
~~~
#### И самое главное - поймать!
~~~php
try {
    throw new Exception('Aaa!');
} catch (Exception $exception) {
    // обработка пойманного исключения
}
~~~

Как поймать исключение:
- Нужно обязательно указать класс "ловимого" исключения;
- Будут пойманы те исключения, которые принадлежат этому классу или его наследникам;
- Если нужно ловить вообще все исключения, то catch(Throwable $ex);
- Самое интересное - в catch можно бросить исключение! И оно будет всплывать выше...


#### Механизм, который позволяет выполнить разный код для разных классов исключений:
~~~php
try {
    ...
} catch (Exception1 $ex) {
    // some code with Exception1
} catch (Exception2 $ex) {
    // some code with Exception1
}
~~~
Или выполнить код после обработки всех исключений (или даже если их не было):
~~~php
try {
    ...
} catch (Exception $ex) {
    ...
} finally {
    // закончили!
}
~~~

Если требуется дополнительная информация, к вашему классу исключения, помимо того что дает системный класс Exception, необходимо расширить этот класс
~~~php
// DbException.php
class DbException extends \Exception
{
    protected $query;
    
    public function __construct($query, $message = "",$code = 0,Throwable $previous = null)
    {
        $this->query = $query;
        parent::__construct($message,$code,$previous);
    }
    
    public function getQuery()
    {
        return $this->query;
    }
}


// Db.php
class Db
{
    public function query($sql, $data = [], $class)
    {
        $sth - $this->dbh->prepare($sql);
        $res = $sth->execute($data);
        
        if (!$res) {
            throw new DbException($sql, 'Запрос не может быть выполнен!');
        }
        
        return $sth->fetchAll(\PDO::FETCH_CLASS, $class);
    }
}


// index.php
try {
    $class = 'App\Controller\\' . $ctrl;
    $ctrl = new $class;
} catch (DbException $error) {
    echo 'Db Error: ' . $error->getQuery() . ' ' . $error->getMessage();
    die();
} catch (Exception $error) {
    echo 'Error';
    die();
}
~~~

### Выполнение кода после обработки всех исключений (или даже если их не было):
- Выполняется код в блоке try, если не было никаких исключений, то сразу блок finally;
- Если есть исключения, то по блокам catch, но потом finally все равно исполняем;

Блок finally часто применяется для закрытия ресурсов, которые были ранее открыты.
___

## Про оператор return и finally

~~~php
function div($x, $y) {
    try {
        if (0 == $y) {
            throw new DivideByZeroException('Деление на 0');
        }
        return $x / $y;
    } catch (Throwable $error) {
        echo $error->getMessage();
        return null;
    } finally {
        echo 'Это была функция деления';
    }
}

var_dump(div(6, 2,));       // Это была функция деления. int 3

var_dump(div(6, 0));        // Деление на 0. Это была функция деления. null
~~~

Мы ожидаем, что return остановит выполнение функции, нам вернется число 3, и мы увидим число 3.

На самом деле происходит следующее: блок finally выполнится уже как бы после завершения работы функции.

В случае если у нас есть try, catch, finally, код из finally берется в некий кармашек и держится там, 
если сработает корректный return, то сначала перед ним выполняется finally, а потом return.

___


## Практика применения
#### Где в php есть исключения?
1. В SPL (Standard PHP Library). Она содержит в себе десяток готовых стандартных классов исключений:
- BadMethodCallException
- InvalidArgumentException
- RangeException
- InvalidArgumentException
- и другие

2. PDO:
~~~php
try {
    $dbh = new PDO($dsn);
} catch (PDOException $e) {
    echo 'Ошибка БД:' .
    $e->getMessage();
}
~~~
___ 


## Мультиисключение: архитектурное упражнение:
- Это исключение;
- Которое в свою очередь является коллекцией других исключений;
- Позволяет добавлять исключения в себя, получать список, удалять.

Весьма неплохо применяется для валидации форм, моделей, в тех случаях, когда нужно хранить информацию о 
нескольких исключительных ситуациях сразу.

~~~php
// Errors.php
class Errors extends Exception
{
    protected $errors = [];
    
    public function add(Exception $e)
    {
        $this->errors[] = $e;
    }
    
    public function all()
    {
        return $this->errors;
    }
    
    public function empty()
    {
        return empty($this->errors);
    }
}

// Login.php
class Login extends Controller
{
    ...
    
    protected function handle()
    {
        if (!empty($_POST['login']) && !empty($_POST['password'])) {
            $password = $_POST['password'];
            
            $errors = new Errors();
            
            if (strlen($password) < 6) {
                $errors->add(new Exception('Пароль короткий'));
            }
            
            if (false !== strpos($password, '+')) {
                $errors->add(new Exception('Пароль +'))
            }
            
            if (!$errors->empty()) {
                throw $errors;
            }
        }
       
        echo $this->view->render(__DIR__ . '/../login.php');
    }
}
~~~

___

## Как все-таки применять исключения?
- Определить свою иерархию исключений. Сделайте исключения моделей, например. Или исключение "не найдена запись в таблице". Или исключения для введенных пользователем данных;
- Определить "опасный код". Убедиться, что выбрасываются исключения во всех исключительных ситуациях;
- Ловить все исключения. Стараться ловить их раньше, не давая всплывать до верхних слоев;
- Убедится, что ловите ВСЕ исключения (в этом правиле не должно быть исключений).