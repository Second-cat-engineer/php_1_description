## Работа с файлами на сервере. Загрузка от клиента.
***

## Цикл "Пока" While 
### while (условие) { тело цикла } - цикл будет выполняться пока условие истина.

- Предусловие
~~~php
$i = 1;
while ($i < 10) {
    echo $i;
    $++;
} 
~~~
- Пост-условие (выполнится хотя бы один раз)
~~~php
$i = 1;
do {
    echo $i;
    $++;
} while ($i < 10) 
~~~
___


## Чтение из файлов
### Способы прочитать данные из файла в свою программу.
- Для начала нужно открыть файл. При это получим "ресурс" - ссылку на открытый файл, с которой потом можно работать:
~~~php
$res = fopen(Путь к файлу, 'r');
~~~
- А затем в цикле читать строки из файла:
~~~php
while (!feof($res)) {
    $line = fgets($res, 1024);
}
~~~
- И закрыть файл:
~~~php
fclose($res);
~~~

#### Resource - тип связей с открытым ресурсом. Ресурсом может быть файл, соединение с БД, сетевое соединение с удаленным сервером, в общем все то, что можно читать, во что можно писать.
~~~php
$res = fopen(Путь к файлу, 'r');
while (!feof($res)) {
    $line = fgets($res, 1024);
}
fclose($res);
~~~

file get string принимает ресурс открытого файла, а возвращает строчку прочитанную из файла как будто если бы он быт текстовым файлом (от начала до перевода строки).
Если fgets вызывать несколько раз, т.е. после вызова функции в первый раз, внутренний указатель переместится до конца строки, и следующий вызов функции прочитает вторую строку и оставит курсор на третьем.


### Функции
- fopen() - открывает файл или url. Возвращает указатель на файл или false в случае ошибки;
- fclose() - закрывает открытый дескриптор файла;
- fread($handle, int $length) - бинарно-безопасное чтение файла. Читает до length байт из файлового указателя handle и смещает указатель;
- fgets() - читает строку из файла. Возвращает строку размером length - 1 байт или false.


### Еще способы прочитать данные из файла
- $lines = file(ПУТЬ); - Читает содержимое файла целиком и возвращает массив, в котором каждый элемент это строка из этого файла (FILE_IGNORE_NEW_LINES);
- $str = file_get_contents(ПУТЬ); - Чтение целиком файла в строку. Самый оптимальный по производительности вариант;
- readfile() - читает файл и записывает его в буфер вывода. Возвращает количество прочитанных из файла байт в случае успеха, или false (E_WARNING);
- file_exists() - проверяет существование указанного файла или каталога. Возвращает true или false (E_WARNING);
- is_readable() - определяет существует ли файл, и доступен ли он для чтения.
___


## Запись в файл
### Способы из программы записать данные в файл:
1. Все под контролем, зато трудоемкий:
~~~php
$res = fopen(Путь к файлу, 'w');
fwrite($res, $data); // string!
fclose($res);
~~~
Режимы открытия файлов:
- r - чтение;
- r+ - чтение и запись;
- w - запись. Файл будет создан, если не существовал или "обнулен";
- w+ - запись и чтение. Файл будет создан, если не существовал или "обнулен";
- a - запись. Файл будет создан, если не существовал. Запись в конец файла;
2. file_put_contents(ПУТЬ, $data); - в этом случае все режимы открытия/закрытия контролируются.
___


## INCLUDE
Это же близко к "чтению из файлов", не так ли?
~~~php
// foo.php

$res = 2 + 2;
return $res;
~~~
~~~php
// index.php

$foo = include(__DIR__ . '/foo.php');
echo $foo;
~~~

#### Таким образом файлы в php, как функции, могут возвращать значения с помощью оператора return. Чтобы это значение получить - достаточно получить то, что вернет конструкция include.
___


## Средства работы с файловой системой
- scandir($path - Возвращает массив имён всех файлов, содержащихся в папке $path;
- dirname($path) - Имя родительской папки для указанного файла (или папки);
- pathinfo($path) - Возвращает массив с частями пути (путь, имя файла, расширение);
- filesize($path) - Размер файла $path в байтах;
- realpath($path) - Возвращает канонический абсолютный путь для указанного. Раскрывает все «.», «..», ссылки и так далее;
___


## Загрузка файлов
#### Для того чтобы иметь возможность загрузить файлы от клиента (из браузера) на сервер, нужно:
- Специальным образом построить форму загрузки:
~~~html
<form
    action="/upload.php"
    method="post"
    enctype="multipart/form-data"
>
    <input type="file" name="myimg">
</form>
~~~
- Прочитать данные из суперглобального массива $_FILES:
~~~php
if (isset($_FILES['myimg'])) {
    if (0 == $_FILES['myimg']['error']) {
        $res = move_uploaded_file(
            $_FILES['myimg']['tmp_name'], // временное хранилище
            ПОЛНЫЙПУТЬНОВОЕИМЯНАСЕРВЕРЕ   // куда сохранить
        );
    }
}
~~~
move_uploaded_file() - в рамках безопасности дополнительно проверяет что этот файл был загружен от клиента в рамках текущей сессии

#### Важно:
- Обращать внимание на размер загружаемого файла, на него могут быть установлены ограничения на сервере;
- Использовать корректные пути.
