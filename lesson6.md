## Классы и объекты. Введение в ООП.
***

## Класс - описание будущих объектов.
### Класс в php:
~~~php
class Table {
    public $color;
    public $legs;
}
~~~
Указанный код не производит никаких активных действий, просто определяет класс.
Для того чтобы использовать класс, нужно создать объект.
Класс можно рассматривать как чертеж для объекта, и на основе этого класса создаем объект.

### Для создания объекта:
~~~php
$table = new Table();
~~~
Такая запись значит что создан новый объект класса Table;

Объект - это с одной стороны, обычная переменная. Ее можно передать в функцию или использовать еще как-то.

С другой стороны, объект имеет свойства, те, которые описаны в классе.

Доступ к свойствам через ->
~~~php
$table->color = 'red';
$table->legs = 4;
~~~

### Метод объекта:
#### Это функция, определенная в классе, и связанная с объектом этого класса.
~~~php
class Table {
    public $color;
    public $legs;
    
    public function show() {
      echo 'Привет, я стол!';
      echo 'О ' . $this->legs . 'ногах';
    }  
}

$table = new Table;
$table->color = 'black';
$table->legs = 4;
$table->show();
~~~
##### Действует интересное правило: в каждый метод неявно прокидывается одна переменная, которая называется $this (этот). Эта переменная всегда доступна в методах объекта и она указывает на тот объект, в контексте которого вызван метод.
___


### Видимость.
~~~php
class Table {
  public $color;
  protected $legs;
}

$table = new Table;
$table->color = 'black';
$table->legs = 4; // ОШИБКА!
~~~

- Ключевое слово protected вместо public приводит к тому, что обращение к свойству (или методу!) напрямую вызывает ошибку;
- Однако «внутри», то есть в методах объекта, через $this, такое свойство/метод по-прежнему доступно;
- Это тоже часть «ИНКАПСУЛЯЦИИ»;
- Совокупность всех публичных свойств и методов называется «интерфейс».
___


### Инкапсуляция (1-й кит ООП) - сокрытие деталей реализации.
 Что это значит?
У нас наружу смотрят простые публичные методы.

Важное свойство ООП: простой интерфейс и скрытая сложность. Сложные детали реализации должны быть скрыты от посторонних глаз, от тех, кто будет объектом пользоваться.

### Наследование (2-1 кит ООП) - передача по "наследству" свойств и методов.
Некий набор свойств общий, некий набор - конкретный. Все общие можно задавать в базовом классе.

Наследование реализуется указанием класса-родителя у класса-наследника через ключевое слово extends
~~~php
class Table extends Item
~~~
- В классе Table свои свойства/методы + Item;
- У предка может быть сколько угодно потомков. У каждого из них могут быть свои потомки. В php нет множественного наследования, т.е. класс Table может унаследовать только от одного класса Item;
- Унаследованные методы можно переписать заново в классах-потомках (перекрыть - написать свою реализацию, улучшить - добавив и обратившись к родителю parent::method());

~~~php
class Item {
    public $price;
    public $color;
    
    public function show() {
        return 'Я стою ' . $this->price;
    }
}

class Cabinet extends Item {
    public $doors;
    
    public function show() {
        return 'Я шкаф о ' . $this->doors . ' дверях. ' . parent::show(); 
    }
}
~~~
___


### Конструктор
Это "магический" метод, который выполняется АВТОМАТИЧЕСКИ при создании объекта класса:
- Метод-конструктор всегда называется __construct();
- Конструктор может и не иметь аргументов (как и любая другая функция!);
- В конструкторе доступна переменная $this, как и в любом другом методе.
~~~php
class Item {
    public $price;
    
    public function __construct($price) {
        $this->price = $price;
    }
}

$table = new Item(1000);
~~~

Когда вызывается оператор new, создается объект заданного класса, дальше php смотрит есть ли у него конструктор, если есть, то автоматически вызывает.
Если конструктор требует какие-то аргументы, то их надо указать после имени класса, иначе ничего не получится.